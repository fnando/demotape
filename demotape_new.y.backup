class DemoTape::Parser
rule
  # Top level: document is a flat list of tokens and contexts
  document: items { result = val[0].flatten.compact }
          | /* empty */ { result = [] }

  items: item { result = [val[0]] }
       | items item { result = val[0] << val[1] }

  # An item can be a token or a context
  item: COMMENT { result = make_token(:comment, val[0], @token_index - 1) }
      | NEWLINE { result = make_token(:newline, val[0], @token_index - 1) }
      | LEADING_SPACE { result = make_token(:leading_space, val[0], @token_index - 1) }
      | TRAILING_SPACE { result = make_token(:trailing_space, val[0], @token_index - 1) }
      | command_line { result = val[0] }
      | group_context { result = val[0] }

  # A command line: tokens terminated by newline
  command_line: command_tokens NEWLINE {
                  result = [{
                    type: :command,
                    tokens: val[0],
                    line: line_for_token_at(@command_start_index),
                    column: column_for_token_at(@command_start_index)
                  }, make_token(:newline, val[1], @token_index - 1)]
                }

  leading_space: LEADING_SPACE { result = make_token(:leading_space, val[0], @token_index - 1) }

  trailing_space: TRAILING_SPACE { result = make_token(:trailing_space, val[0], @token_index - 1) }

  # Group context: Group name do ... end
  group_context: IDENTIFIER SPACE IDENTIFIER SPACE DO NEWLINE group_body END {
                   @command_start_index = @token_index - 8
                   result = {
                     type: :group,
                     name: val[2],
                     tokens: [
                       make_token(:identifier, val[0], @token_index - 8),
                       make_token(:space, val[1], @token_index - 7),
                       make_token(:identifier, val[2], @token_index - 6),
                       make_token(:space, val[3], @token_index - 5),
                       make_token(:keyword, "do", @token_index - 4)
                     ],
                     body: val[6],
                     line: line_for_token_at(@token_index - 8),
                     column: column_for_token_at(@token_index - 8)
                   }
                 }

  group_body: /* empty */ { result = [] }
            | group_body item { result = val[0] << val[1] }

  # Command tokens: any sequence of tokens until newline
  command_tokens: command_token { @command_start_index = @token_index - 1; result = [val[0]] }
                | command_tokens SPACE command_token { result = val[0] << make_token(:space, val[1], @token_index - 2) << val[2] }
                | command_tokens optional_space COMMA optional_space command_token {
                    result = val[0]
                    result << make_token(:space, val[1], @token_index - 4) if val[1]
                    result << make_token(:operator, ",", @token_index - 3)
                    result << make_token(:space, val[3], @token_index - 2) if val[3]
                    result << val[4]
                  }
                | command_tokens PLUS command_token {
                    result = val[0] << make_token(:operator, "+", @token_index - 2) << val[2]
                  }
                | command_tokens AT duration {
                    result = val[0] << make_token(:operator, "@", @token_index - 2) << val[2]
                  }

  optional_space: SPACE { result = val[0] }
                | /* empty */ { result = nil }

  command_token: IDENTIFIER { result = make_token(:identifier, val[0], @token_index - 1) }
               | STRING { result = make_token(:string, val[0], @token_index - 1) }
               | NUMBER { result = make_token(:number, val[0], @token_index - 1) }
               | REGEX { result = make_token(:regex, val[0], @token_index - 1) }

  duration: NUMBER TIME_UNIT {
              result = make_token(:duration, "#{val[0]}#{val[1]}", @token_index - 2)
            }

---- header
  require_relative "token"
  require_relative "lexer"
  require_relative "ast"

---- inner
  def parse(str, file: "<unknown>")
    @file = file
    @lexer = DemoTape::Lexer.new
    @tokens = @lexer.tokenize(str)
    @token_index = 0
    do_parse
  end

  def next_token
    token = @tokens.shift
    @current_token_index = @token_index
    @token_index += 1
    token
  end

  def make_token(type, value, index)
    line_info = @lexer.line_map[index] || {}
    token_class = case type
                  when :identifier then DemoTape::Token::Identifier
                  when :string then DemoTape::Token::String
                  when :number then DemoTape::Token::Number
                  when :duration then DemoTape::Token::Duration
                  when :regex then DemoTape::Token::Regex
                  when :time_unit then DemoTape::Token::TimeUnit
                  when :operator then DemoTape::Token::Operator
                  when :space then DemoTape::Token::Space
                  when :leading_space then DemoTape::Token::LeadingSpace
                  when :trailing_space then DemoTape::Token::TrailingSpace
                  when :keyword then DemoTape::Token::Keyword
                  when :comment then DemoTape::Token::Comment
                  when :newline then DemoTape::Token::Newline
                  else DemoTape::Token::Base
                  end

    token_class.new(
      value,
      line: line_info[:line],
      column: line_info[:column],
      raw: line_info[:raw]
    )
  end

  def line_for_token_at(index)
    line_info = @lexer.line_map[index] || {}
    line_info[:line]
  end

  def column_for_token_at(index)
    line_info = @lexer.line_map[index] || {}
    line_info[:column]
  end

  def collect_tokens(*values)
    values.flatten.compact.select { |v| v.is_a?(DemoTape::Token::Base) }
  end

  def on_error(token_id, token_value, value_stack)
    line_info = @lexer.line_map[@current_token_index] || {}
    line_num = line_info[:line] || "?"
    col_num = line_info[:column] || 1
    line_content = line_info[:content] || ""

    token_name = token_to_str(token_id) || token_id.to_s

    error_msg = "Unexpected token #{token_name.inspect} at #{@file}:#{line_num}:#{col_num}:\n"
    error_msg += "  #{line_content.strip}\n"
    error_msg += "  #{' ' * (col_num - line_content.length + line_content.strip.length - 1)}^"

    raise DemoTape::ParseError, error_msg
  end

---- footer
